Instalação do Django

1 - Instala o venv;
2 - Ativa o venv;
3 - python -m pip install Django; 
3.1 - python, import django, print(django.get_version()), exit();
3.2 - python -m django --version
---
Agora, precisamos auto-gerar um código para estabelecer um projeto Django;

- django-admin startproject mysite

Semântica dos arquivos:

- manage.py -> Utilitário CLI que te ajuda interagir com o Django de várias formas;
- __init__.py -> Um arquivo vazio que diz ao Python que este diretório deve ser considerado um pacote
- settings.py -> Arquivo com toda a configuração do seu Django;
- urls.py -> Área de declaração de URLs;
- asgi.py -> Ponto de entrada para web servers compatíveis com ASGI;
- wsgi.py -> Ponto de entrada para web servers compatíveis com ASGI;
---
Inicializando o servidor:

- python manage.py runserver

Dá pra especificar a porta do runserver -> python manage.py runserver 8080, por exemplo;
---
Criando um App:

python manage.py startapp myapp
---
Exemplo de app:

View mais simples possível em views.py

from django.http import HttpResponse

def index(response):
       return HttpResponse("ola mundo! ")

Para chamarmos a view, precisamos mapeá-la na URL, para isso usaremos o URLconf;

Para criar a URLconf no nosso myapp, crie um arquivo chamado urls.py;

Exemplo de código para criação das urls:

# Add aqui depois o ponteiro
from django.urls import path

from . import views

urlpatterns = [
   path('', views.index, name='index'),
]

O próximo passo é apontar a URLconf no mysite.urls dentro do urls.py DO MYSITE **

from django.contrib import admin
from django.urls import include, path

urlpatterns = [
   path('myapp/', include('myapp.urls')),
   path('admin/', admin.site.urls),
]
---
O path() recebe quatro argumentos

route, path, kwargs e name;
---
Configurando Banco de Dados SQLite

No settings.py:

- ENGINE -> é É o SGBD usado;
- NAME -> É o nome do seu banco de dados;

Obs: se você não está usando o SQLite, é necessário passar configurações opcionais, tipo: USER, PASSWORD, e HOST;

Obs: note que o INSTALLED_APPS no topo da página contém

- django.contrib.admin -> O site do administrador;
- django.contrib.auth -> Sistema de autenticação do Django;
- django.contrib.contenttypes -> Um framework para tipos de conteúdo;
django.contrib.sessions -> Framework para gerenciamento de sessões;
django.contrib.messages -> Um framework para mensagens;
django.contrib.staticfiles -> Um framework para gerenciamento de arquivos de estáticos;

Para criar uma tabela

python manage.py migrate
---
Criando Models

Exemplo de código em myapp/models.py

from django.db import models

class Question(models.Model):
   question_text = models.CharField(max_length=200)
pub_date = models.DateTimeField('date published')

class Choice(models.Model):
   question = models.ForeignKey(Question, on_delete=models.CASCADE)
   choice_text = models.CharField(max_length=200)
   votes = models.IntegerField(default=0)

Agora, precisamos informar o projeto que myapp está instalado, para isso, precisamos referenciar a classe de configuração do myapp no settings do mysite. Esta classe normalmente fica dentro do myapp -> apps.py -> MyAppConfig

Dentro do settings.py:

INSTALLED_APPS = [
'myapp.apps.MyappConfig',
...]

Agora rodamos novamente o makemigrations do manage.py

python manage.py makemigrations myapp

O makemigrations diz ao Python que você fez alterações a suas models e você quer salvá-las como uma migration;

Agora usa o migrate para aplicar no seu BD

python manage.py migrate

Em suma o ciclo de três passos de migrations do Django é

- Mude suas models em models.py;
- Execute o python manage.py makemigrations;
- Execute manage.py migrate;

Rodando a shell do manage.py

python manage.py shell

Exemplos de testes com a API

from myapp.models import Choice, Question

Question.objects.all()

# Use o timezone.now() ao invés do datetime no Django

from django.utils import timezone
# Criando um objeto no BD
q = Question(question_text="What's new?", pub_date=timezone.now())

# Salvando no BD
q.save()

# Printando id
q.id

# Printando question_text
q.question_text

# Printando q.pub_date
q.pub_date

# Mudando os atributos
q.question_text = "Olá"

# Sempre lembre de salvar no BD
q.save()

É muito importante adicionarmos o dunder __str__() para quando retornarmos o Question.objects.all(), pois se não é retornado <Question: Question object (1)>

Então adicionamos em cada model algo assim:

def __str__(self):
   return self.question_text
...

Podemos testar outras coisas com o filter também:

# Filtrando lista por id
Question.objects.filter(id=1)

# Filtrando por texto inicial
Question.objects.filter(question_text__startswith="What")

# Pegando a questão publicada esse ano
current_year = timezone.now().year

Question.objects.get(pub_date__year=current_year)

# Buscando por Chave Primária

Question.objects.get(pk=1)

# Deletando instância
c.delete()

# Associando FK, PK
c.question=q

Obs: note o uso de Field Lookups com o Django filters -> MyModel.objects.filter(att_name__startswith="L")

Segue a referência de filter no Django:

https://www.w3schools.com/django/django_ref_filter.php

Segue a referência de field lookups no Django:

https://www.w3schools.com/django/django_ref_field_lookups.php
---
Introdução ao Django Admin

Primeiro crie um usuário que possa usar a pg

- python manage.py createsuperuser

Obs: você pode colocar em PT-BR a página usando o LANGUAGE_CODE no settings.py, nas datas também usando o TIME_ZONE;

Para adicionar a interface do admin as nossas models

from django.contrib import admin

from .models import Question

admin.site.register(Question)
---
Views

O URLconfs ou URL dispatcher é útil para mapear URL patterns em views;

Exemplos de view

def detail(request, question_id):
   return HttpResponse("You are looking at question %s.", % (question_id))

def results(request, question_id):
   response = "You're looking at the results of question %s."
   return HttpResponse(response % question_id)
   
def vote(request, question_id):
   return HttpResponse("You're voting on question %s." % question_id)

Agora nós precisamos mapear usando o path no urls.py

from .models import views

urlpatterns = [
   path('<int:question_id>/', views.detail, name='detail'),
   path('<int:question_id>/results/', views.results, name='results'),
   path('<int:question_id>/vote/', views.vote, name='vote'),
]

Exemplo mostrando view que imprime lista filtrada do BD

from .models import Question

def listit(request):
   # Mostra as 5 pub_dates mais recentes
   latest_question_list = Question.objects.order_by("-pub_date")[:5]

# Imprime q que é igual a cada q.question_text dentro de latest_question_list com uma vírgula a cada q

   output = ', '.join([q.question_text for q in latest_question_list])

   return HttpResponse(output)
---
TEMPLATES

Primeiro crie um diretório templates no myapp;

Daí crie um diretório myapp dentro e uma index.html dentro dele;

Graças ao app_directories, seguindo a convenção myapp/templates/myapp/index.html, faz com que para o Django fique myapp/index.html;

Exemplo de código no Template

{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}

Agora atualiza a view adequada

    path('listit', views.listit, name="list")

Usando o Template

from django.template import loader

...

def index(request):
   latest_question_list = Question.objects.order_by('-pub_date')[:5]
   template = loader.get_template('myapp/index.html')
   context = {
   'latest_question_list': latest_question_list,
   }
   return HttpResponse(template.render(context, request))

Obs: o context é um mapeamento do tipo dicionário que mapeia template variable para objetos Python;

Basicamente o que fizemos foi usar o loader para pegar um template e passar para esse template com o .render o contexto -> Objeto Python que queremos acessar lá e a request;

1 - Carrega o template com o loader.get();

2 - Passar no contexto os objetos desejados;

3 - Retornar uma HttpResponse com o resultado do template renderizado;

Ou você pode simplificar esse processo usando o render():

from django.shortcuts import render

from .models import Question

def index(request):
   latest_question_list = Question.objects.order_by("-pub_date")[:5]

   context = {
      'latest_question_list': latest_question_list
   }

    return render(request, 'myapp/index.html', context)

Exemplo de gerenciamento de erros

from django.http import Http404

def detail(request, question_id):
   try:
      Question.objects.get(pk=question_id)
   except Question.DoesNotExist:
   raise Http404("Question not found! ")
   return HttpResponse("You're looking at question {0}! ".format(question_id))

Agora usando um atalho do Django

from django.shortcuts import get_object_or_404, render

...

def detail(request, question_id):
   question = get_object_or_404(Question, pk=question_id)
   return render(request, 'myapp/detail.html', {'question': question})

Exemplo de template novo de detail

<h1>{{ question.question_text }}</h1>

{% for choice in question.choice_set.all %}
   <li>{{ choice.choice_text }}</li>

{% endfor %}
</ul>

O sistema de template do Django usa {{}} para atributos variáveis e {%%} para chamadas de método;

Uma forma de melhorar o url binding na rota dinâmico com híperlinks é:

ao invés de -> <li><a href="/myapp/{{ question.id }}/" />{{ question.question_text }}</li>

podemos -> <li><a href="{% url 'detail' question.id %}" />{{ question.question_text }}</li>

Nesse caso acima o Django basicamente busca a url com name = 'detail' e concatena essa url com o question.id;

Para agrupar urlpatterns use namespace. Por exemplo

app_name='myapp'
urlpatterns=[...]

Agora mude sua url dinâmica para:

<li><a href="{% url 'myapp:detail' question.id %}" />{{ question.question_text }}</li>
---
Formulários

<form action="{% url 'myapp:vote' question.id %}" method="post">
   {% csrf_token %}
   <fieldset>
       <legend><h1>{{ question.question_text }}</h1></legend>
       {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}
       {% for choice in question.choice_set.all %}
           <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
           <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
       {% endfor %}
   </fieldset>
   <input type="submit" value="Vote">
   </form>

O forloop.counter é um método do Django que emula o enumerate();

Agora implementando view de  vote

from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse

from .models import Choice, Question
# ...
def vote(request, question_id):
    # Verificamos com try except e raise Http404 se o Question com id=question_id, existe no Banco de Dados
    question = get_object_or_404(Question, pk=question_id)
    try:
        # Agora, a gente pega a question.choice que tem pk = à requisição do tipo POST com dado = 'choice'
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Enviando ao template uma resposta com os objetos question e error_message
        return render(request, 'myapp/detail.html', {
            'question': question,
            'error_message': "You did not selected a choice! ",
        })
    else:
        # Soma um no selected_choice.votes e salva no BD
        selected_choice.votes += 1
        selected_choice.save()

        # Retorna com o redirect pra não dar erro de submit duplo
        # Note o reverse, que permite não violação do DRY
        return HttpResponseRedirect(reverse('myapp:results', args=(question_id,)))

Vale atentar-se ao race condition;

Podemos usar um atalho para esses processos anteriores, chamado "generic views";

Convertendo código para generic views

...
from django.urls import path

from . import views

app_name = 'polls'
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    path('<int:pk>/results/', views.ResultsView.as_view(), name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]

Agora nas views

from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.views import generic

from .models import Choice, Question


class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        """Return the last five published questions."""
        return Question.objects.order_by('-pub_date')[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'


class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'


def vote(request, question_id):
    ... # same as above, no changes needed.
---
Tests

import datetime
from django.utils import timezone
from django.test import TestCase

from .models import Question

class QuestionModelTests(TestCase):
    def test_was_published_recently_with_future_question(self):
        time = timezone.now() + timezone.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertIs(future_question.was_published_recently(), False)

Agora para rodar o teste -> python manage.py test myapp

Ambiente de testes do Django

from django.test.utils import setup_test_environment

setup_test_environment

from django.test import Client

client = Client()

response = client.get('/')

response.status_code

from django.urls import reverse

response = client.get(reverse('myapp:index'))
response.status_code

response.content

response.context['latest_question_list']

Em relação a testes mais é melhor;
---
Arquivos estáticos

Cria uma pasta static dentro do myapp e depois crie um folder myapp dentro dele, depois crie um stylesheet.css, que será refereciado como -> myapp/style.css

Depois de estilizar, dentro de index.html, faça

{% load static %}

<link rel="stylesheet" href="{% static 'myapp/style.css' %}"

O static aqui gera o caminho geral pra pasta static do myapp

Imagens idealmente devem ir -> myapp/static/myapp/images
---
Customizando Admin

Modidicando a pg de adm

...
class QuestionAdmin(admin.ModelAdmin):
   fields = ['pub_date', 'question_text']

admin.site.register(Question, QuestionAdmin)

Alterando fieldsets

class QuestionAdmin(...)...
   fieldsets = [
      (None, {'fields': ['question_text']}),
      ('Date information', {'fields': ['pub_date']}),
   ]

Note o None no fieldset 1, isso remove o fieldset da row

Facilitando o processo de FK, PK no admin

class ChoiceInline(admin.StackedInline):
   model = Choice
   # Extra = linhas de choice
   extra = 3

class QuestionAdmin()...
   ...
   inlines = [ChoiceInline]
...

Isso diz ao Django que a model choices deve ser alterável através da model Question 

Ao invés de printarmos o objeto com o str() podemos sobrescrever esse comportamento com

class QuestionAdmin...
   list_display = ('question_text', 'pub_date', 'was_published_recently')

Dá para manipular como os dados são mostrados na pg de admin usando o decorador @admin

Em models

from django.contrib import admin

class Question...
   def __str__...


   @admin.display(
      boolean = True,
      ordering = 'pub_date',
      description = 'Published Recently?',
   )

Em admin.py na QuestionAdmin

# Filtrando objetos por 'pub_date'
  list_filter = ['pub_date']

# Adicionando barra de pesquisa para 'question_text'

search_fields = ['question_text']

Nota-se o uso conjunto de Change, list pagination, search boxes, filters, date-hierarchies e column-header-ordering para uma melhor experiência
---
Modificando o Template

Em settings.py na opção de TEMPLATES

1 - Adiciona uma DIRS:
'DIRS': [BASE_DIR / 'templates']

2 - Agora cria um folder admin em templates/mysite(folder pai do myapp)

3 - Copia o admin/base_site.html pra lá

4 - Modifica como quiser
Obs: Dá pra fazer a mesma coisa com outros arquivos do adm
---
Autenticação e Autorização

